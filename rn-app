Klar! Hier ist eine detaillierte Anleitung, wie du dein bestehendes Web-Frontend mit React Native als mobile App umsetzt und mit deinem Backend verbindest.

# Detaillierter Implementationsplan: Intranet-Projekt als React Native App

## 1. Projektstruktur & Integration mit bestehendem Backend

### 1.1 Projektstruktur anpassen
```bash
# Neuen app-Ordner im Hauptverzeichnis erstellen
mkdir -p app
cd app

# React Native Projekt initialisieren
npx react-native init IntranetMobile --template react-native-template-typescript

# Verzeichnisstruktur nach VIBES.md anlegen
mkdir -p src/{api,assets,components,contexts,hooks,navigation,screens,services,types,utils,config,styles}
```

Die finale Projektstruktur wird so aussehen:
```
/intranet
  /backend          # Bestehendes Backend (bleibt unverändert)
  /frontend         # Web-Frontend (bleibt unverändert)
  /app              # Neues React Native Frontend
    /src            # React Native App-Quellcode
```

### 1.2 Abhängigkeiten installieren
```bash
# Basis-Abhängigkeiten
npm install axios react-hook-form yup @react-navigation/native @react-navigation/stack @react-navigation/bottom-tabs
# UI-Komponenten
npm install react-native-paper react-native-vector-icons
# Weitere notwendige Pakete für React Native
npm install react-native-screens react-native-safe-area-context react-native-gesture-handler
# AsyncStorage für lokales Speichern (ersetzt localStorage im Web)
npm install @react-native-async-storage/async-storage
```

### 1.3 Backend-Konfiguration
- Erstelle `src/config/api.ts` mit der Backend-URL-Konfiguration:
```typescript
// Entwicklungsumgebung: lokale IP deines Entwicklungsrechners verwenden
// für den Emulator funktioniert localhost nicht direkt, daher IP-Adresse verwenden
export const API_URL = __DEV__ 
  ? 'http://192.168.1.X:5000' // Deine lokale IP + Port des Backends
  : 'https://deine-produktions-domain.com/api';

export const API_TIMEOUT = 10000; // 10 Sekunden Timeout
```

- Erstelle `src/config/axios.ts` mit der Axios-Konfiguration (synchronisiert mit dem Web-Frontend):
```typescript
import axios from 'axios';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { API_URL } from './api';

// Exakt die gleiche Konfiguration wie im Web-Frontend, nur mit AsyncStorage statt localStorage
const axiosInstance = axios.create({
  baseURL: API_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request Interceptor für Token-Handling
axiosInstance.interceptors.request.use(
  async (config) => {
    const token = await AsyncStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

export default axiosInstance;
```

## 2. API-Integration mit bestehendem Backend

### 2.1 Wiederverwendung der API-Clients
- Kopiere und adaptiere die API-Client-Implementierungen aus `frontend/src/api/` in `app/src/api/`
- Erstelle `src/api/apiClient.ts` basierend auf dem bestehenden Web-Frontend-Code:

```typescript
import axiosInstance from '../config/axios';

// Gleiche Struktur wie im Web-Frontend
const apiClient = axiosInstance;

// Exportiere die gleichen API-Clients wie im Web-Frontend
export const userApi = {
  getAll: () => apiClient.get('/users'),
  getById: (id: number) => apiClient.get(`/users/${id}`),
  update: (id: number, data: any) => apiClient.put(`/users/${id}`, data),
  updateRoles: (id: number, roleIds: number[]) => apiClient.put(`/users/${id}/roles`, { roleIds })
};

export const roleApi = {
  getAll: () => apiClient.get('/roles'),
  getById: (id: number) => apiClient.get(`/roles/${id}`),
  create: (data: any) => apiClient.post('/roles', data),
  update: (id: number, data: any) => apiClient.put(`/roles/${id}`, data),
  delete: (id: number) => apiClient.delete(`/roles/${id}`)
};

export default apiClient;
```

### 2.2 Code-Sharing mit dem Web-Frontend
Für maximale Wiederverwendung und DRY-Konformität:

- Erstelle einen Symlink zu gemeinsam genutzten Typen:
```bash
# Optional: Symbolische Links zu gemeinsamen Typdefinitionen
ln -s ../../frontend/src/types ./src/types/web
```

- Oder kopiere und synchronisiere sie manuell:
```bash
# Alternativ: Manuelles Kopieren
cp -r ../frontend/src/types/* ./src/types/
```

### 2.3 Module-spezifische APIs implementieren
- Adaptiere alle bestehenden API-Module aus `frontend/src/api/`:
  - `src/api/worktimeApi.ts` - Zeiterfassung
  - `src/api/notificationApi.ts` - Benachrichtigungen
  - `src/api/cerebroApi.ts` - Wiki-System
  - etc.

## 3. Typdefinitionen 

### 3.1 Typen aus Web-Frontend übernehmen
- Kopiere alle relevanten Typdefinitionen aus `frontend/src/types/` in `app/src/types/`
- Erstelle `src/types/index.ts` mit gemeinsamen Typen:

```typescript
// Gleiche Typen wie im Web-Frontend (aus Prisma-Schema)
export enum TaskStatus {
  OPEN = 'open',
  IN_PROGRESS = 'in_progress',
  DONE = 'done',
  BLOCKED = 'blocked',
  CANCELED = 'canceled'
}

export enum RequestStatus {
  APPROVAL = 'approval',
  DENIED = 'denied',
  WAITING = 'waiting',
  IN_PROGRESS = 'in_progress',
  DONE = 'done',
  CANCELED = 'canceled'
}

export enum AccessLevel {
  NONE = 'none',
  READ = 'read',
  WRITE = 'write',
  ADMIN = 'admin'
}

// Weitere Typen aus dem Web-Frontend
```

### 3.2 React Native spezifische Typen
- Erstelle `src/types/navigation.ts` für die React Navigation Typen:

```typescript
import { StackNavigationProp } from '@react-navigation/stack';
import { RouteProp } from '@react-navigation/native';

// Definiere alle App-Screens
export type RootStackParamList = {
  Login: undefined;
  Dashboard: undefined;
  Worktime: undefined;
  Profile: undefined;
  Settings: undefined;
  // Weitere Screens...
};

// Typen für Navigation Props
export type RootStackNavigationProp<T extends keyof RootStackParamList> = 
  StackNavigationProp<RootStackParamList, T>;

export type RootStackRouteProp<T extends keyof RootStackParamList> = 
  RouteProp<RootStackParamList, T>;
```

## 4. Context-Providers adaptieren

### 4.1 Authentifizierungs-Context
- Adaptiere den Auth-Context aus dem Web-Frontend für React Native:
```typescript
import React, { createContext, useState, useContext, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import apiClient from '../api/apiClient';

// Gleiche Struktur wie im Web-Frontend, nur mit AsyncStorage statt localStorage
interface AuthContextData {
  user: any | null;
  loading: boolean;
  signIn: (credentials: { username: string; password: string }) => Promise<void>;
  signOut: () => void;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextData>({} as AuthContextData);

export const AuthProvider: React.FC = ({ children }) => {
  const [user, setUser] = useState<any | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadStoredData() {
      const storedUser = await AsyncStorage.getItem('user');
      const storedToken = await AsyncStorage.getItem('token');
      
      if (storedUser && storedToken) {
        setUser(JSON.parse(storedUser));
      }
      
      setLoading(false);
    }
    
    loadStoredData();
  }, []);

  const signIn = async (credentials: { username: string; password: string }) => {
    try {
      const response = await apiClient.post('/auth/login', credentials);
      const { token, user } = response.data;
      
      await AsyncStorage.setItem('token', token);
      await AsyncStorage.setItem('user', JSON.stringify(user));
      
      setUser(user);
    } catch (error) {
      throw error;
    }
  };

  const signOut = async () => {
    await AsyncStorage.removeItem('user');
    await AsyncStorage.removeItem('token');
    setUser(null);
  };

  return (
    <AuthContext.Provider 
      value={{ 
        user, 
        loading, 
        signIn, 
        signOut,
        isAuthenticated: !!user 
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export function useAuth(): AuthContextData {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
}
```

### 4.2 Weitere Contexts adaptieren
- Kopiere und adaptiere die weiteren Contexts aus dem Web-Frontend:
  - `src/contexts/ThemeContext.tsx` (anpassen für React Native Paper)
  - `src/contexts/WorktimeContext.tsx` (gleiche Logik, angepasste UI-Interaktionen)
  - `src/contexts/MessageContext.tsx` (für Toast-Benachrichtigungen in React Native)

## 5. Navigation implementieren

### 5.1 Navigationsstruktur anlegen
- Erstelle `src/navigation/index.tsx`:
```typescript
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { useAuth } from '../contexts/AuthContext';

// Screens importieren
import LoginScreen from '../screens/LoginScreen';
import DashboardScreen from '../screens/DashboardScreen';
import WorktimeScreen from '../screens/WorktimeScreen';
import ProfileScreen from '../screens/ProfileScreen';
import SettingsScreen from '../screens/SettingsScreen';

const AppStack = createStackNavigator();
const AuthStack = createStackNavigator();
const Tab = createBottomTabNavigator();

// Tab-Navigation für authentifizierte Benutzer
const TabNavigator = () => (
  <Tab.Navigator>
    <Tab.Screen name="Dashboard" component={DashboardScreen} />
    <Tab.Screen name="Worktime" component={WorktimeScreen} />
    <Tab.Screen name="Profile" component={ProfileScreen} />
    <Tab.Screen name="Settings" component={SettingsScreen} />
  </Tab.Navigator>
);

// Auth-Navigation für nicht authentifizierte Benutzer
const AuthNavigator = () => (
  <AuthStack.Navigator screenOptions={{ headerShown: false }}>
    <AuthStack.Screen name="Login" component={LoginScreen} />
  </AuthStack.Navigator>
);

// Haupt-Navigation
const AppNavigator = () => {
  const { isAuthenticated, loading } = useAuth();

  if (loading) {
    // Loading-Screen rendern
    return null;
  }

  return (
    <NavigationContainer>
      {isAuthenticated ? (
        <AppStack.Navigator screenOptions={{ headerShown: false }}>
          <AppStack.Screen name="Main" component={TabNavigator} />
        </AppStack.Navigator>
      ) : (
        <AuthNavigator />
      )}
    </NavigationContainer>
  );
};

export default AppNavigator;
```

### 5.2 Screen-Komponenten implementieren
Für jeden wichtigen Bereich aus `frontend/src/pages/`:

1. **LoginScreen.tsx**:
```typescript
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { TextInput, Button, Text } from 'react-native-paper';
import { useAuth } from '../contexts/AuthContext';

const LoginScreen = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const { signIn } = useAuth();

  const handleLogin = async () => {
    try {
      await signIn({ username, password });
    } catch (err) {
      setError('Ungültige Anmeldedaten');
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Intranet Login</Text>
      
      {error ? (
        <Text style={styles.error}>{error}</Text>
      ) : null}
      
      <TextInput
        label="Benutzername"
        value={username}
        onChangeText={setUsername}
        style={styles.input}
      />
      
      <TextInput
        label="Passwort"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={styles.input}
      />
      
      <Button mode="contained" onPress={handleLogin}>
        Anmelden
      </Button>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    justifyContent: 'center',
  },
  title: {
    fontSize: 24,
    marginBottom: 24,
    textAlign: 'center',
  },
  input: {
    marginBottom: 16,
  },
  error: {
    color: 'red',
    marginBottom: 16,
  },
});

export default LoginScreen;
```

## 6. Implementierung der Hauptmodule

### 6.1 Zeiterfassung (Worktracker)
- Adaptiere die Logik aus `frontend/src/pages/Worktracker.tsx` zu `app/src/screens/WorktimeScreen.tsx`
- Nutze die gleichen API-Aufrufe und Geschäftslogik mit angepasster UI für Mobile
- Implementiere Timer-Funktionalität mit React Native
- Speichere Zeiteinträge lokal und synchronisiere mit dem bestehenden Backend

### 6.2 Profilverwaltung
- Adaptiere die Logik aus `frontend/src/pages/Profile.tsx` zu `app/src/screens/ProfileScreen.tsx`
- Implementiere Zugriff auf Benutzerdetails und Einstellungen
- Verwende die gleichen API-Endpunkte wie das Web-Frontend

### 6.3 Benachrichtigungssystem
- Erstelle `src/services/notificationService.ts` für Push-Benachrichtigungen
- Integriere mit dem bestehenden Backend-Notification-System
- Verwende die gleichen API-Endpunkte wie im Web-Frontend

## 7. Native Funktionalitäten integrieren

### 7.1 Kameraintegration für Dokumentenerkennung
```bash
npm install react-native-camera react-native-vision-camera
```

- Implementiere `src/components/DocumentScanner.tsx` für OCR-Funktionalität
- Verwende die bestehenden Backend-Endpunkte für die Dokumentverarbeitung

### 7.2 Biometrische Authentifizierung
```bash
npm install react-native-biometrics
```

- Erweitere den Auth-Context um biometrische Login-Option
- Integriere mit dem bestehenden Authentifizierungssystem

### 7.3 Offline-Modus
- Implementiere Daten-Caching mit AsyncStorage
- Erstelle Synchronisationslogik für Offline-Änderungen
- Verbessere die Benutzererfahrung bei instabiler Verbindung

## 8. Backend-Integration verbessern

### 8.1 Backend-CORS-Konfiguration
- Überprüfe, ob die CORS-Einstellungen im Backend die App-Zugriffe erlauben:
```typescript
// In backend/src/app.ts
app.use(cors({
  origin: ['http://localhost:3000', 'exp://YOUR-EXPO-URL', 'YOUR-NATIVE-APP-SCHEMA://'],
  credentials: true
}));
```

### 8.2 API-Optimierungen für mobile Geräte
- Identifiziere mobile Clients durch Headers:
```typescript
// In den API-Anfragen im App-Client
headers: {
  'X-Client-Type': 'mobile'
}
```

- Optional: Erweitere Backend-Endpunkte für optimierte mobile Responses:
```typescript
// Im Backend: Daten für mobile Clients optimieren
if (req.headers['x-client-type'] === 'mobile') {
  // Weniger Daten zurückgeben, optimiert für mobile Bandbreite
}
```

## 9. UI/UX-Anpassungen

### 9.1 Theming nach DESIGN_STANDARDS
- Erstelle `src/styles/theme.ts` mit Farbschema und Typografie, abgestimmt auf das Web-Frontend
- Implementiere responsives Design für verschiedene Bildschirmgrößen

### 9.2 Wiederverwendbare Komponenten
- Adaptiere bestehende UI-Komponenten aus dem Web-Frontend für mobile Nutzung:
  - `src/components/DataTable.tsx` (für Listen statt Tabellen)
  - `src/components/FilterSystem.tsx` (mobile-optimiert)
  - `src/components/SearchField.tsx` (für Touch-Interaktion optimiert)

## 10. Testing-Strategie

### 10.1 Unit-Tests
```bash
npm install --save-dev jest @testing-library/react-native
```

- Erstelle Tests für kritische Geschäftslogik:
  - Authentifizierung und API-Integration
  - Zeiterfassung und Synchronisation
  - Offline-Funktionalität

### 10.2 E2E-Tests
```bash
npm install --save-dev detox
```

- Implementiere kritische Benutzerpfade:
  - Login und Authentifizierung
  - Zeiterfassung starten/stoppen
  - Synchronisation mit dem Backend

## 11. Deployment-Vorbereitung

### 11.1 App-Icons & Splash-Screens
```bash
npx react-native-asset
```

- Erstelle Assets für verschiedene Gerätetypen/Auflösungen
- Verwende das bestehende Branding aus dem Web-Frontend

### 11.2 App-Konfiguration
- Konfiguriere app.json/Info.plist/AndroidManifest.xml
- Definiere verschiedene Umgebungen (dev, staging, production)
- Bereite Veröffentlichungspakete vor

## 12. Wichtige Richtlinien und Einschränkungen

### 12.1 VIBES.md Konformität
- Implementiere DRY-Prinzipien (Don't Repeat Yourself)
- Teile Code zwischen Web und Mobile wo sinnvoll
- Folge Sicherheitsrichtlinien für Eingabevalidierung und Datenschutz
- Setze Performance-Optimierungen nach VIBES.md um

### 12.2 Serverseitige Beschränkungen
- **WICHTIG**: Server (Port 5000) NIEMALS neu starten!
- **WICHTIG**: Prisma Studio (Port 5555) NIEMALS neu starten!
- Alle Backend-Änderungen mit Vorsicht durchführen

### 12.3 Dokumentation
- Dokumentiere alle implementierten Features nach DOKUMENTATIONSSTANDARDS
- Halte Stufe-3-Dokumentation aktuell
- Dokumentiere mobile-spezifische Anpassungen

## Detaillierter Fahrplan (mit Abhängigkeiten)

1. **Basis-Setup (Woche 1)**
   - Ordnerstruktur erstellen und in das Hauptprojekt integrieren
   - Abhängigkeiten installieren
   - Integration mit bestehendem Backend konfigurieren

2. **Core-Implementierung (Woche 1-2)**
   - Auth-Kontext implementieren
   - Navigation aufbauen
   - Login-Screen implementieren
   - Basis-API-Integration mit bestehendem Backend

3. **Hauptmodule (Woche 2-3)**
   - Zeiterfassung implementieren
   - Benutzerprofil umsetzen
   - Benachrichtigungen integrieren
   - Integration mit bestehenden Backend-Endpunkten

4. **Erweiterte Funktionen (Woche 3-4)**
   - Offline-Modus implementieren
   - Native Funktionen integrieren
   - Mobile-spezifische Optimierungen

5. **Qualitätssicherung (kontinuierlich)**
   - Tests implementieren
   - Backend-Integration testen
   - UI/UX-Verbesserungen

6. **Deployment (Woche 4-5)**
   - App-Paketierung vorbereiten
   - Testversionen für Benutzerakzeptanztests verteilen
   - Produktionsvorbereitung

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       Int                           @id @default(autoincrement())
  username                 String                        @unique
  password                 String
  firstName                String?
  lastName                 String?
  birthday                 DateTime?
  bankDetails              String?
  contract                 String?
  salary                   Float?
  createdAt                DateTime                      @default(now())
  updatedAt                DateTime                      @updatedAt
  email                    String                        @unique
  country                  String                        @default("CO")
  hourlyRate               Decimal?
  language                 String                        @default("es")
  normalWorkingHours       Float                         @default(7.6)
  payrollCountry           String                        @default("CH")
  approvedOvertimeHours    Float                         @default(0)
  contractType             String?
  monthlySalary            Float?
  employeeNumber           String?
  identificationNumber     String?
  taxIdentificationNumber  String?
  gender                   String? // "male", "female", "other"
  active                   Boolean                       @default(true)
  carticlesCreated         CerebroCarticle[]             @relation("CarticleCreator")
  carticlesUpdated         CerebroCarticle[]             @relation("CarticleUpdater")
  externalLinks            CerebroExternalLink[]
  cerebroMedia             CerebroMedia[]
  consultationInvoices     ConsultationInvoice[]
  payrolls                 EmployeePayroll[]
  identificationDocuments  IdentificationDocument[]
  invoiceSettings          InvoiceSettings?
  monthlyReports           MonthlyConsultationReport[]
  notifications            Notification[]
  invitationsAccepted      OrganizationInvitation[]      @relation("InvitationAcceptor")
  invitationsSent          OrganizationInvitation[]      @relation("Inviter")
  joinRequestsProcessed    OrganizationJoinRequest[]     @relation("JoinProcessor")
  joinRequestsSent         OrganizationJoinRequest[]     @relation("JoinRequester")
  requestsRequester        Request[]                     @relation("requester")
  requestsResponsible      Request[]                     @relation("responsible")
  requestsDeleted          Request[]                     @relation("RequestDeleter") // NEU
  savedFilters             SavedFilter[]
  filterGroups             FilterGroup[]
  settings                 Settings?
  tasksQualityControl      Task[]                        @relation("quality_control")
  tasksResponsible         Task[]                        @relation("responsible")
  tasksCreated             Task[]                        @relation("TaskCreator") // NEU
  tasksDeleted             Task[]                        @relation("TaskDeleter") // NEU
  userNotificationSettings UserNotificationSettings?
  roles                    UserRole[]
  tableSettings            UserTableSettings[]
  requestStatusChanges     RequestStatusHistory[]        @relation("request_status_changes") // NEU
  branches                 UsersBranches[]
  workTimes                WorkTime[]
  taskStatusChanges        TaskStatusHistory[]           @relation("task_status_changes")
  employeeLifecycle        EmployeeLifecycle?
  lifecycleEventsTriggered LifecycleEvent[]              @relation("LifecycleEventTriggerer")
  certificatesGenerated    EmploymentCertificate[]       @relation("CertificateGenerator")
  contractsGenerated       EmploymentContract[]          @relation("ContractGenerator")
  passwordResetTokens      PasswordResetToken[]
  onboardingCompleted      Boolean                       @default(false)
  onboardingProgress       Json? // Speichert den Fortschritt: { currentStep: number, completedSteps: number[] }
  onboardingStartedAt      DateTime?
  onboardingCompletedAt    DateTime?
  onboardingEvents         OnboardingEvent[]
  profileComplete          Boolean                       @default(false) // Profilvollständigkeit nach Registrierung (username, email, country, language)
  phoneNumber              String? // WhatsApp-Telefonnummer (mit Ländercode, z.B. +573001234567)
  whatsappConversations    WhatsAppConversation[]
  shifts                   Shift[]
  availabilities           UserAvailability[]
  createdShifts            Shift[]                       @relation("ShiftCreator")
  confirmedShifts          Shift[]                       @relation("ShiftConfirmer")
  swapRequestsSent         ShiftSwapRequest[]            @relation("SwapRequester")
  swapRequestsReceived     ShiftSwapRequest[]            @relation("SwapRequestee")
  toursCreated             Tour[]                        @relation("TourCreator")
  toursBooked              TourBooking[]                 @relation("TourBooker")
  passwordEntriesCreated   PasswordEntry[]               @relation("PasswordEntryCreator")
  passwordEntryPermissions PasswordEntryUserPermission[]
  passwordEntryAuditLogs   PasswordEntryAuditLog[]       @relation("PasswordEntryAuditLogUser")
  pricingRulesCreated      PricingRule[]
}

model Organization {
  id                   Int                         @id @default(autoincrement())
  name                 String                      @unique
  displayName          String
  domain               String?                     @unique
  logo                 String?
  isActive             Boolean                     @default(true)
  maxUsers             Int                         @default(50)
  subscriptionPlan     String                      @default("basic")
  subscriptionEnd      DateTime?
  settings             Json?
  country              String? // Land der Organisation (z.B. "CO" für Kolumbien)
  nit                  String? // NIT (Número de Identificación Tributaria) für Kolumbien
  createdAt            DateTime                    @default(now())
  updatedAt            DateTime                    @updatedAt
  invitations          OrganizationInvitation[]
  joinRequests         OrganizationJoinRequest[]
  roles                Role[]
  tasks                Task[]
  requests             Request[]
  workTimes            WorkTime[]
  clients              Client[]
  branches             Branch[]
  consultationInvoices ConsultationInvoice[]
  monthlyReports       MonthlyConsultationReport[]
  carticles            CerebroCarticle[]
  employeeLifecycles   EmployeeLifecycle[]
  reservations         Reservation[]
  tours                Tour[]                      @relation("Tours")
  tourBookings         TourBooking[]               @relation("TourBookings")
  tourProviders        TourProvider[]              @relation("TourProviders")
  passwordEntries      PasswordEntry[]
}

model OrganizationJoinRequest {
  id             Int               @id @default(autoincrement())
  organizationId Int
  requesterId    Int
  status         JoinRequestStatus @default(pending)
  message        String?
  response       String?
  processedBy    Int?
  processedAt    DateTime?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  organization   Organization      @relation(fields: [organizationId], references: [id])
  processor      User?             @relation("JoinProcessor", fields: [processedBy], references: [id])
  requester      User              @relation("JoinRequester", fields: [requesterId], references: [id])

  @@unique([organizationId, requesterId])
}

model OrganizationInvitation {
  id             Int          @id @default(autoincrement())
  organizationId Int
  email          String
  roleId         Int
  invitedBy      Int
  token          String       @unique
  expiresAt      DateTime
  acceptedAt     DateTime?
  acceptedBy     Int?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  acceptor       User?        @relation("InvitationAcceptor", fields: [acceptedBy], references: [id])
  inviter        User         @relation("Inviter", fields: [invitedBy], references: [id])
  organization   Organization @relation(fields: [organizationId], references: [id])
  role           Role         @relation(fields: [roleId], references: [id])
}

model Role {
  id                       Int                           @id @default(autoincrement())
  name                     String
  description              String?
  organizationId           Int?
  allBranches              Boolean                       @default(false) // Wenn true, gilt für alle Branches der Organisation
  invitations              OrganizationInvitation[]
  permissions              Permission[]
  organization             Organization?                 @relation(fields: [organizationId], references: [id])
  tasks                    Task[]
  users                    UserRole[]
  branches                 RoleBranch[] // Spezifische Branch-Zuweisungen (nur wenn allBranches = false)
  shiftTemplates           ShiftTemplate[]
  shifts                   Shift[]
  availabilities           UserAvailability[]
  passwordEntryPermissions PasswordEntryRolePermission[]

  @@unique([name, organizationId])
}

model UserRole {
  id        Int      @id @default(autoincrement())
  userId    Int
  roleId    Int
  lastUsed  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      Role     @relation(fields: [roleId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, roleId])
}

model Permission {
  id          Int      @id @default(autoincrement())
  roleId      Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  accessLevel String
  entity      String
  entityType  String   @default("page")
  role        Role     @relation(fields: [roleId], references: [id])
}

model Branch {
  id                            Int                          @id @default(autoincrement())
  name                          String                       @unique
  createdAt                     DateTime                     @default(now())
  updatedAt                     DateTime                     @updatedAt
  organizationId                Int?
  organization                  Organization?                @relation(fields: [organizationId], references: [id])
  whatsappSettings              Json? // WhatsApp-Konfiguration pro Branch
  lobbyPmsSettings              Json? // NEU: LobbyPMS-Konfiguration pro Branch
  lobbyPmsLastSyncAt            DateTime? // OPTIMIERUNG: Letzte erfolgreiche LobbyPMS Sync-Zeit (für Caching)
  boldPaymentSettings           Json? // NEU: Bold Payment-Konfiguration pro Branch
  doorSystemSettings            Json? // NEU: TTLock/Türsystem-Konfiguration pro Branch
  emailSettings                 Json? // NEU: Email-Konfiguration pro Branch (SMTP + IMAP)
  messageTemplates              Json? // NEU: Konfigurierbare Mitteilungsvorlagen (Check-in-Einladung, Check-in-Bestätigung)
  autoSendReservationInvitation Boolean?                     @default(false) // NEU: Automatisches Versenden von Check-in-Einladungen aktivieren/deaktivieren
  address                       String? // NEU: Straße und Hausnummer (z.B. "Cl 11A #43d-86")
  city                          String? // NEU: Stadt (z.B. "Medellín")
  country                       String? // NEU: Land (z.B. "Kolumbien")
  requests                      Request[]
  tasks                         Task[]
  users                         UsersBranches[]
  workTimes                     WorkTime[]
  taskStatusChanges             TaskStatusHistory[]
  requestStatusChanges          RequestStatusHistory[] // NEU: Request Status-Historie
  roles                         RoleBranch[] // Rollen, die für diese Branch verfügbar sind
  whatsappConversations         WhatsAppConversation[]
  whatsappMessages              WhatsAppMessage[]            @relation("WhatsAppMessages")
  phoneNumberMappings           WhatsAppPhoneNumberMapping[]
  shiftTemplates                ShiftTemplate[]
  shifts                        Shift[]
  availabilities                UserAvailability[]
  reservations                  Reservation[] // NEU: Relation zu Reservierungen
  tours                         Tour[]                       @relation("TourBranches")
  tourBookings                  TourBooking[]                @relation("TourBookingBranches")
  tourProviders                 TourProvider[]               @relation("TourProviderBranches")
  otaListings                   OTAListing[]
  priceAnalyses                 PriceAnalysis[]
  priceRecommendations          PriceRecommendation[]
  pricingRules                  PricingRule[]
  rateShoppingJobs              RateShoppingJob[]
  competitorGroups              CompetitorGroup[]
}

model UsersBranches {
  id        Int      @id @default(autoincrement())
  userId    Int
  branchId  Int
  lastUsed  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  branch    Branch   @relation(fields: [branchId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, branchId])
}

model RoleBranch {
  id        Int      @id @default(autoincrement())
  roleId    Int
  branchId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      Role     @relation(fields: [roleId], references: [id])
  branch    Branch   @relation(fields: [branchId], references: [id])

  @@unique([roleId, branchId])
}

model WorkTime {
  id              Int                        @id @default(autoincrement())
  userId          Int
  branchId        Int
  startTime       DateTime
  endTime         DateTime?
  createdAt       DateTime                   @default(now())
  updatedAt       DateTime                   @updatedAt
  timezone        String?
  clientId        Int?
  notes           String?
  monthlyReportId Int?
  organizationId  Int?
  organization    Organization?              @relation(fields: [organizationId], references: [id])
  invoiceItems    ConsultationInvoiceItem[]
  branch          Branch                     @relation(fields: [branchId], references: [id])
  client          Client?                    @relation(fields: [clientId], references: [id])
  monthlyReport   MonthlyConsultationReport? @relation(fields: [monthlyReportId], references: [id])
  user            User                       @relation(fields: [userId], references: [id])
  taskLinks       WorkTimeTask[]
}

model Task {
  id               Int                   @id @default(autoincrement())
  title            String
  description      String?
  status           TaskStatus            @default(open)
  responsibleId    Int?
  qualityControlId Int
  branchId         Int
  dueDate          DateTime?
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  roleId           Int?
  organizationId   Int?
  createdById      Int? // NEU: Wer hat den Task erstellt
  deletedAt        DateTime? // NEU: Soft Delete
  deletedById      Int? // NEU: Wer hat den Task gelöscht
  organization     Organization?         @relation(fields: [organizationId], references: [id])
  branch           Branch                @relation(fields: [branchId], references: [id])
  qualityControl   User                  @relation("quality_control", fields: [qualityControlId], references: [id])
  responsible      User?                 @relation("responsible", fields: [responsibleId], references: [id])
  role             Role?                 @relation(fields: [roleId], references: [id])
  createdBy        User?                 @relation("TaskCreator", fields: [createdById], references: [id])
  deletedBy        User?                 @relation("TaskDeleter", fields: [deletedById], references: [id])
  attachments      TaskAttachment[]
  carticles        TaskCerebroCarticle[]
  workTimeLinks    WorkTimeTask[]
  statusHistory    TaskStatusHistory[]
  reservationId    Int?                  @unique
  reservation      Reservation?          @relation(fields: [reservationId], references: [id])

  // Performance-Indizes für Filter-Queries
  @@index([reservationId])
  @@index([organizationId, status, createdAt(sort: Desc)])
  @@index([responsibleId])
  @@index([qualityControlId])
  @@index([status])
  @@index([branchId])
  @@index([roleId])
  @@index([dueDate])
  @@index([title]) // Für contains/startsWith/endsWith Filter
  @@index([createdById, createdAt(sort: Desc)]) // NEU: Für Analytics
  @@index([deletedAt]) // NEU: Für Soft Delete Filter
  @@index([deletedById]) // NEU: Für Analytics
}

model Request {
  id             Int                      @id @default(autoincrement())
  title          String
  description    String?
  status         RequestStatus            @default(approval)
  type           RequestType              @default(other)
  isPrivate      Boolean                  @default(false)
  requesterId    Int
  responsibleId  Int
  branchId       Int
  dueDate        DateTime?
  createTodo     Boolean                  @default(false)
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  organizationId Int?
  deletedAt      DateTime? // NEU: Soft Delete
  deletedById    Int? // NEU: Wer hat den Request gelöscht
  organization   Organization?            @relation(fields: [organizationId], references: [id])
  branch         Branch                   @relation(fields: [branchId], references: [id])
  requester      User                     @relation("requester", fields: [requesterId], references: [id])
  responsible    User                     @relation("responsible", fields: [responsibleId], references: [id])
  deletedBy      User?                    @relation("RequestDeleter", fields: [deletedById], references: [id])
  attachments    RequestAttachment[]
  carticles      RequestCerebroCarticle[]
  statusHistory  RequestStatusHistory[] // NEU: Status-Historie

  // Performance-Indizes für Filter-Queries
  @@index([organizationId, isPrivate, createdAt(sort: Desc)])
  @@index([requesterId, isPrivate])
  @@index([responsibleId, isPrivate])
  @@index([status])
  @@index([type])
  @@index([branchId])
  @@index([dueDate])
  @@index([title]) // Für contains/startsWith/endsWith Filter
  @@index([deletedAt]) // NEU: Für Soft Delete Filter
  @@index([deletedById]) // NEU: Für Analytics
  @@index([requesterId, createdAt(sort: Desc)]) // NEU: Für Analytics (bereits vorhanden, aber explizit dokumentiert)
}

model Settings {
  id               Int      @id @default(autoincrement())
  userId           Int      @unique
  companyLogo      String?
  darkMode         Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  sidebarCollapsed Boolean  @default(false)
  user             User     @relation(fields: [userId], references: [id])
}

model UserTableSettings {
  id            Int      @id @default(autoincrement())
  userId        Int
  tableId       String
  columnOrder   String
  hiddenColumns String
  viewMode      String? // 'table' oder 'cards'
  sortConfig    String? // JSON: { key: string, direction: 'asc' | 'desc' }
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User     @relation(fields: [userId], references: [id])

  @@unique([userId, tableId])
}

model FilterGroup {
  id        Int           @id @default(autoincrement())
  userId    Int
  tableId   String
  name      String
  order     Int           @default(0)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id])
  filters   SavedFilter[]

  @@unique([userId, tableId, name])
}

model SavedFilter {
  id         Int          @id @default(autoincrement())
  userId     Int
  tableId    String
  name       String
  conditions String
  operators  String
  groupId    Int?
  order      Int          @default(0)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  user       User         @relation(fields: [userId], references: [id])
  group      FilterGroup? @relation(fields: [groupId], references: [id])

  @@unique([userId, tableId, name])
}

model Notification {
  id                Int              @id @default(autoincrement())
  userId            Int
  title             String
  message           String
  type              NotificationType
  read              Boolean          @default(false)
  relatedEntityId   Int?
  relatedEntityType String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  carticleId        Int?
  carticle          CerebroCarticle? @relation(fields: [carticleId], references: [id])
  user              User             @relation(fields: [userId], references: [id])
}

model NotificationSettings {
  id                  Int      @id @default(autoincrement())
  taskCreate          Boolean  @default(true)
  taskUpdate          Boolean  @default(true)
  taskDelete          Boolean  @default(true)
  taskStatusChange    Boolean  @default(true)
  requestCreate       Boolean  @default(true)
  requestUpdate       Boolean  @default(true)
  requestDelete       Boolean  @default(true)
  requestStatusChange Boolean  @default(true)
  userCreate          Boolean  @default(true)
  userUpdate          Boolean  @default(true)
  userDelete          Boolean  @default(true)
  roleCreate          Boolean  @default(true)
  roleUpdate          Boolean  @default(true)
  roleDelete          Boolean  @default(true)
  worktimeStart       Boolean  @default(true)
  worktimeStop        Boolean  @default(true)
  worktimeAutoStop    Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  carticleCreate      Boolean  @default(true)
  carticleDelete      Boolean  @default(true)
  carticleLink        Boolean  @default(true)
  carticleMention     Boolean  @default(true)
  carticleUpdate      Boolean  @default(true)
  worktimeManagerStop Boolean  @default(true)
}

model UserNotificationSettings {
  id                             Int      @id @default(autoincrement())
  userId                         Int      @unique
  taskCreate                     Boolean?
  taskUpdate                     Boolean?
  taskDelete                     Boolean?
  taskStatusChange               Boolean?
  requestCreate                  Boolean?
  requestUpdate                  Boolean?
  requestDelete                  Boolean?
  requestStatusChange            Boolean?
  userCreate                     Boolean?
  userUpdate                     Boolean?
  userDelete                     Boolean?
  roleCreate                     Boolean?
  roleUpdate                     Boolean?
  roleDelete                     Boolean?
  worktimeStart                  Boolean?
  worktimeStop                   Boolean?
  worktimeAutoStop               Boolean? @default(true)
  createdAt                      DateTime @default(now())
  updatedAt                      DateTime @updatedAt
  carticleCreate                 Boolean?
  carticleDelete                 Boolean?
  carticleLink                   Boolean?
  carticleMention                Boolean?
  carticleUpdate                 Boolean?
  worktimeManagerStop            Boolean?
  joinRequestApproved            Boolean?
  joinRequestReceived            Boolean?
  joinRequestRejected            Boolean?
  organizationInvitationReceived Boolean?
  shiftAssigned                  Boolean?
  shiftUpdated                   Boolean?
  shiftCancelled                 Boolean?
  shiftSwapRequest               Boolean?
  shiftSwapApproved              Boolean?
  shiftSwapRejected              Boolean?
  user                           User     @relation(fields: [userId], references: [id])
}

model EmployeePayroll {
  id                              Int      @id @default(autoincrement())
  userId                          Int
  periodStart                     DateTime
  periodEnd                       DateTime
  regularHours                    Float
  overtimeHours                   Float
  nightHours                      Float
  holidayHours                    Float
  hourlyRate                      Decimal
  grossPay                        Decimal
  socialSecurity                  Decimal
  taxes                           Decimal
  netPay                          Decimal
  createdAt                       DateTime @default(now())
  updatedAt                       DateTime @updatedAt
  currency                        String   @default("CHF")
  deductions                      Decimal  @default(0)
  overtimeNightHours              Float    @default(0)
  overtimeNightSundayHolidayHours Float    @default(0)
  overtimeSundayHolidayHours      Float    @default(0)
  sundayHolidayHours              Float    @default(0)
  user                            User     @relation(fields: [userId], references: [id])
}

model CerebroCarticle {
  id             Int                      @id @default(autoincrement())
  title          String
  content        String?
  slug           String                   @unique
  parentId       Int?
  createdById    Int
  updatedById    Int?
  isPublished    Boolean                  @default(false)
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  position       Int?                     @default(999)
  githubPath     String?
  organizationId Int?
  organization   Organization?            @relation(fields: [organizationId], references: [id])
  createdBy      User                     @relation("CarticleCreator", fields: [createdById], references: [id])
  parent         CerebroCarticle?         @relation("Hierarchy", fields: [parentId], references: [id])
  children       CerebroCarticle[]        @relation("Hierarchy")
  updatedBy      User?                    @relation("CarticleUpdater", fields: [updatedById], references: [id])
  externalLinks  CerebroExternalLink[]
  media          CerebroMedia[]
  notifications  Notification[]
  requests       RequestCerebroCarticle[]
  tasks          TaskCerebroCarticle[]
  tags           CerebroTag[]             @relation("CerebroCarticleToCerebroTag")
}

model TaskCerebroCarticle {
  id         Int             @id @default(autoincrement())
  taskId     Int
  carticleId Int
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  carticle   CerebroCarticle @relation(fields: [carticleId], references: [id])
  task       Task            @relation(fields: [taskId], references: [id])

  @@unique([taskId, carticleId])
}

model RequestCerebroCarticle {
  id         Int             @id @default(autoincrement())
  requestId  Int
  carticleId Int
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  carticle   CerebroCarticle @relation(fields: [carticleId], references: [id])
  request    Request         @relation(fields: [requestId], references: [id])

  @@unique([requestId, carticleId])
}

model CerebroMedia {
  id          Int             @id @default(autoincrement())
  path        String
  filename    String
  mimetype    String
  size        Int
  carticleId  Int
  createdById Int
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  carticle    CerebroCarticle @relation(fields: [carticleId], references: [id])
  createdBy   User            @relation(fields: [createdById], references: [id])
}

model CerebroExternalLink {
  id          Int             @id @default(autoincrement())
  url         String
  title       String?
  type        String
  carticleId  Int
  createdById Int
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  carticle    CerebroCarticle @relation(fields: [carticleId], references: [id])
  createdBy   User            @relation(fields: [createdById], references: [id])
}

model CerebroTag {
  id        Int               @id @default(autoincrement())
  name      String            @unique
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  carticles CerebroCarticle[] @relation("CerebroCarticleToCerebroTag")
}

model TaskAttachment {
  id         Int      @id @default(autoincrement())
  taskId     Int
  fileName   String
  fileType   String
  fileSize   Int
  filePath   String
  uploadedAt DateTime @default(now())
  task       Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
}

model RequestAttachment {
  id         Int      @id @default(autoincrement())
  requestId  Int
  fileName   String
  fileType   String
  fileSize   Int
  filePath   String
  uploadedAt DateTime @default(now())
  request    Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)
}

model IdentificationDocument {
  id               Int       @id @default(autoincrement())
  userId           Int
  documentType     String
  documentNumber   String
  issueDate        DateTime?
  expiryDate       DateTime?
  issuingCountry   String
  issuingAuthority String?
  documentFile     String?
  isVerified       Boolean   @default(false)
  verificationDate DateTime?
  verifiedBy       Int?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  user             User      @relation(fields: [userId], references: [id])

  @@unique([userId, documentType])
}

model Client {
  id                   Int                             @id @default(autoincrement())
  name                 String
  company              String?
  email                String?
  phone                String?
  address              String?
  notes                String?
  isActive             Boolean                         @default(true)
  createdAt            DateTime                        @default(now())
  updatedAt            DateTime                        @updatedAt
  organizationId       Int?
  organization         Organization?                   @relation(fields: [organizationId], references: [id])
  consultationInvoices ConsultationInvoice[]
  monthlyReportItems   MonthlyConsultationReportItem[]
  workTimes            WorkTime[]
}

model ConsultationInvoice {
  id             Int                       @id @default(autoincrement())
  invoiceNumber  String
  clientId       Int
  userId         Int
  issueDate      DateTime                  @default(now())
  dueDate        DateTime
  status         InvoiceStatus             @default(DRAFT)
  subtotal       Decimal                   @db.Decimal(10, 2)
  vatRate        Decimal?                  @db.Decimal(5, 2)
  vatAmount      Decimal?                  @db.Decimal(10, 2)
  total          Decimal                   @db.Decimal(10, 2)
  currency       String                    @default("CHF")
  paymentTerms   String                    @default("30 Tage netto")
  notes          String?
  pdfPath        String?
  qrReference    String?
  createdAt      DateTime                  @default(now())
  updatedAt      DateTime                  @updatedAt
  organizationId Int?
  organization   Organization?             @relation(fields: [organizationId], references: [id])
  client         Client                    @relation(fields: [clientId], references: [id])
  user           User                      @relation(fields: [userId], references: [id])
  items          ConsultationInvoiceItem[]
  payments       InvoicePayment[]
}

model ConsultationInvoiceItem {
  id          Int                 @id @default(autoincrement())
  invoiceId   Int
  workTimeId  Int
  description String
  quantity    Decimal             @db.Decimal(10, 2)
  unitPrice   Decimal             @db.Decimal(10, 2)
  amount      Decimal             @db.Decimal(10, 2)
  createdAt   DateTime            @default(now())
  invoice     ConsultationInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  workTime    WorkTime            @relation(fields: [workTimeId], references: [id])

  @@unique([invoiceId, workTimeId])
}

model InvoicePayment {
  id            Int                 @id @default(autoincrement())
  invoiceId     Int
  amount        Decimal             @db.Decimal(10, 2)
  paymentDate   DateTime
  paymentMethod String
  reference     String?
  notes         String?
  createdAt     DateTime            @default(now())
  invoice       ConsultationInvoice @relation(fields: [invoiceId], references: [id])
}

model InvoiceSettings {
  id                     Int      @id @default(autoincrement())
  userId                 Int      @unique
  companyName            String
  companyAddress         String
  companyZip             String
  companyCity            String
  companyCountry         String   @default("CH")
  companyPhone           String?
  companyEmail           String?
  companyWebsite         String?
  vatNumber              String?
  iban                   String
  bankName               String?
  defaultHourlyRate      Decimal  @db.Decimal(10, 2)
  defaultVatRate         Decimal? @db.Decimal(5, 2)
  invoicePrefix          String   @default("INV")
  nextInvoiceNumber      Int      @default(1)
  footerText             String?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  monthlyReportDay       Int      @default(25)
  monthlyReportEnabled   Boolean  @default(false)
  monthlyReportRecipient String?
  user                   User     @relation(fields: [userId], references: [id])
}

model MonthlyConsultationReport {
  id             Int                             @id @default(autoincrement())
  userId         Int
  reportNumber   String
  periodStart    DateTime
  periodEnd      DateTime
  recipient      String
  totalHours     Decimal                         @db.Decimal(10, 2)
  totalAmount    Decimal?                        @db.Decimal(10, 2)
  currency       String                          @default("CHF")
  pdfPath        String?
  status         MonthlyReportStatus             @default(GENERATED)
  generatedAt    DateTime                        @default(now())
  createdAt      DateTime                        @default(now())
  updatedAt      DateTime                        @updatedAt
  organizationId Int?
  organization   Organization?                   @relation(fields: [organizationId], references: [id])
  user           User                            @relation(fields: [userId], references: [id])
  items          MonthlyConsultationReportItem[]
  workTimes      WorkTime[]
}

model MonthlyConsultationReportItem {
  id                Int                       @id @default(autoincrement())
  reportId          Int
  clientId          Int
  clientName        String
  totalHours        Decimal                   @db.Decimal(10, 2)
  consultationCount Int
  createdAt         DateTime                  @default(now())
  client            Client                    @relation(fields: [clientId], references: [id])
  report            MonthlyConsultationReport @relation(fields: [reportId], references: [id], onDelete: Cascade)
}

model WorkTimeTask {
  id         Int      @id @default(autoincrement())
  workTimeId Int
  taskId     Int
  createdAt  DateTime @default(now())
  task       Task     @relation(fields: [taskId], references: [id])
  workTime   WorkTime @relation(fields: [workTimeId], references: [id])

  @@unique([workTimeId, taskId])
}

model TaskStatusHistory {
  id        Int         @id @default(autoincrement())
  taskId    Int
  userId    Int
  oldStatus TaskStatus?
  newStatus TaskStatus
  changedAt DateTime    @default(now())
  branchId  Int
  task      Task        @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user      User        @relation("task_status_changes", fields: [userId], references: [id])
  branch    Branch      @relation(fields: [branchId], references: [id])

  @@index([taskId])
  @@index([userId])
  @@index([changedAt])
  @@index([branchId])
}

model RequestStatusHistory {
  id        Int            @id @default(autoincrement())
  requestId Int
  userId    Int
  oldStatus RequestStatus?
  newStatus RequestStatus
  changedAt DateTime       @default(now())
  branchId  Int
  request   Request        @relation(fields: [requestId], references: [id], onDelete: Cascade)
  user      User           @relation("request_status_changes", fields: [userId], references: [id])
  branch    Branch         @relation(fields: [branchId], references: [id])

  @@index([requestId])
  @@index([userId])
  @@index([changedAt])
  @@index([branchId])
}

enum TaskStatus {
  open
  in_progress
  improval
  quality_control
  done
}

enum RequestStatus {
  approval
  approved
  to_improve
  denied
}

enum RequestType {
  vacation
  improvement_suggestion
  sick_leave
  employment_certificate
  event
  permit
  buy_order
  repair
  other
}

enum AccessLevel {
  read
  write
  both
  none
}

enum NotificationType {
  task
  request
  user
  role
  worktime
  system
  cerebro
  worktime_manager_stop
  joinRequest
  joinApproved
  joinRejected
  organizationInvitation
  shift
  shift_swap
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

enum MonthlyReportStatus {
  GENERATED
  SENT
  ARCHIVED
}

enum JoinRequestStatus {
  pending
  approved
  rejected
  withdrawn
}

enum SubscriptionPlan {
  basic
  pro
  enterprise
  trial
}

enum ReservationStatus {
  potential // Potenzielle Reservierung (noch nicht bestätigt)
  confirmed
  notification_sent
  checked_in
  checked_out
  cancelled
  no_show
}

enum PaymentStatus {
  pending
  paid
  partially_paid
  refunded
}

// ============================================
// EMPLOYEE LIFECYCLE MODELS
// ============================================

enum EmployeeStatus {
  onboarding // User wurde hinzugefügt, Onboarding läuft
  active // User ist aktiv beschäftigt
  contract_change // Vertragsänderung läuft
  offboarding // Austritt läuft
  archived // User ist ausgetreten, Daten archiviert
}

enum SocialSecurityStatus {
  not_required // Nicht erforderlich (z.B. EPS bei bestehender Versicherung)
  pending // Anmeldung läuft
  registered // Erfolgreich registriert
  failed // Anmeldung fehlgeschlagen
  deregistered // Abgemeldet
}

model EmployeeLifecycle {
  id             Int            @id @default(autoincrement())
  userId         Int            @unique
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  organizationId Int
  organization   Organization   @relation(fields: [organizationId], references: [id])
  status         EmployeeStatus @default(onboarding)

  // Onboarding-Daten
  onboardingStartedAt   DateTime?
  onboardingCompletedAt DateTime?

  // Vertragsdaten
  contractStartDate DateTime?
  contractEndDate   DateTime?
  contractType      String? // "indefinite", "fixed_term", "temporary", etc.

  // Sozialversicherungen (Kolumbien)
  arlStatus       SocialSecurityStatus @default(pending)
  arlRegisteredAt DateTime?
  arlNumber       String?
  arlProvider     String? // Name der ARL-Versicherung

  epsStatus       SocialSecurityStatus @default(not_required)
  epsRequired     Boolean              @default(false)
  epsRegisteredAt DateTime?
  epsNumber       String?
  epsProvider     String?

  pensionStatus       SocialSecurityStatus @default(pending)
  pensionRegisteredAt DateTime?
  pensionNumber       String?
  pensionProvider     String?

  cajaStatus       SocialSecurityStatus @default(pending)
  cajaRegisteredAt DateTime?
  cajaNumber       String?
  cajaProvider     String?

  // Offboarding-Daten
  exitDate               DateTime?
  exitReason             String? // "resignation", "termination", "contract_end", etc.
  offboardingStartedAt   DateTime?
  offboardingCompletedAt DateTime?

  // Metadaten
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Beziehungen
  lifecycleEvents             LifecycleEvent[]
  employmentCertificates      EmploymentCertificate[]
  employmentContracts         EmploymentContract[]
  socialSecurityRegistrations SocialSecurityRegistration[]

  @@index([organizationId])
  @@index([status])
}

model LifecycleEvent {
  id              Int               @id @default(autoincrement())
  lifecycleId     Int
  lifecycle       EmployeeLifecycle @relation(fields: [lifecycleId], references: [id], onDelete: Cascade)
  eventType       String // "onboarding_started", "document_uploaded", "arl_registered", etc.
  eventData       Json? // Zusätzliche Event-Daten
  triggeredBy     Int? // User-ID, der das Event ausgelöst hat
  triggeredByUser User?             @relation("LifecycleEventTriggerer", fields: [triggeredBy], references: [id])
  createdAt       DateTime          @default(now())

  @@index([lifecycleId])
  @@index([eventType])
}

model EmploymentCertificate {
  id              Int               @id @default(autoincrement())
  lifecycleId     Int
  lifecycle       EmployeeLifecycle @relation(fields: [lifecycleId], references: [id], onDelete: Cascade)
  certificateType String            @default("employment") // "employment", "salary", "work_experience", etc.
  issueDate       DateTime          @default(now())
  pdfPath         String
  templateUsed    String? // Name des verwendeten Templates
  templateVersion String? // Version des Templates (für Nachverfolgbarkeit)
  generatedBy     Int? // User-ID, der das Zertifikat generiert hat
  generatedByUser User?             @relation("CertificateGenerator", fields: [generatedBy], references: [id])
  isLatest        Boolean           @default(true) // Ist dies die neueste Version?
  createdAt       DateTime          @default(now())

  @@index([lifecycleId])
  @@index([isLatest])
}

model EmploymentContract {
  id              Int               @id @default(autoincrement())
  lifecycleId     Int
  lifecycle       EmployeeLifecycle @relation(fields: [lifecycleId], references: [id], onDelete: Cascade)
  contractType    String            @default("employment") // "employment", "amendment", "extension", etc.
  startDate       DateTime
  endDate         DateTime?
  salary          Float?
  workingHours    Float?
  position        String?
  pdfPath         String
  templateUsed    String?
  templateVersion String?
  generatedBy     Int?
  generatedByUser User?             @relation("ContractGenerator", fields: [generatedBy], references: [id])
  isLatest        Boolean           @default(true)
  createdAt       DateTime          @default(now())

  // Beziehungen
  contractDocuments ContractDocument[]

  @@index([lifecycleId])
  @@index([isLatest])
}

model ContractDocument {
  id            Int                @id @default(autoincrement())
  contractId    Int
  contract      EmploymentContract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  documentType  String // "original", "amendment", "extension", etc.
  pdfPath       String
  effectiveDate DateTime?
  createdAt     DateTime           @default(now())

  @@index([contractId])
}

model SocialSecurityRegistration {
  id                 Int                  @id @default(autoincrement())
  lifecycleId        Int
  lifecycle          EmployeeLifecycle    @relation(fields: [lifecycleId], references: [id], onDelete: Cascade)
  registrationType   String // "arl", "eps", "pension", "caja"
  registrationNumber String?
  provider           String? // Name des Providers
  registrationDate   DateTime?
  status             SocialSecurityStatus @default(pending)
  notes              String?
  completedBy        Int? // User-ID, der die Anmeldung abgeschlossen hat
  completedAt        DateTime?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt

  @@unique([lifecycleId, registrationType])
  @@index([lifecycleId])
  @@index([registrationType])
}

model PasswordResetToken {
  id        Int      @id @default(autoincrement())
  userId    Int
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
}

// ============================================
// ONBOARDING SYSTEM MODELS
// ============================================

model OnboardingEvent {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stepId    String // ID des Onboarding-Schritts
  stepTitle String // Titel des Schritts (für Reports)
  action    String // 'started', 'completed', 'skipped', 'cancelled'
  duration  Int? // Dauer in Sekunden (für 'completed')
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([stepId])
  @@index([createdAt])
}

// ============================================
// LOBBYPMS RESERVATION MODELS
// ============================================

model Reservation {
  id                       Int                          @id @default(autoincrement())
  lobbyReservationId       String?                      @unique // ID aus LobbyPMS
  guestName                String
  guestEmail               String?
  guestPhone               String?
  checkInDate              DateTime
  checkOutDate             DateTime
  arrivalTime              DateTime? // Geschätzte Ankunftszeit
  roomNumber               String?
  roomDescription          String?
  categoryId               Int? // LobbyPMS category_id (für Zimmer-Beschreibungen)
  status                   ReservationStatus            @default(confirmed)
  paymentStatus            PaymentStatus                @default(pending)
  amount                   Decimal?                     @db.Decimal(10, 2) // Preis der Reservierung
  currency                 String?                      @default("COP") // Währung (COP, USD, EUR, etc.)
  paymentLink              String? // Bold Payment Link
  checkInLink              String? // Check-in-Link (für Online Check-in)
  paymentDeadline          DateTime? // Frist für Zahlung (wird bei Erstellung gesetzt, z.B. 1 Stunde)
  autoCancelEnabled        Boolean                      @default(true) // Automatische Stornierung aktiviert
  cancelledAt              DateTime? // Wann wurde storniert
  cancelledBy              String? // Wer hat storniert ("system" für automatisch, User-ID für manuell)
  cancellationReason       String? // Grund für Stornierung
  doorPin                  String? // PIN für Türsystem
  doorAppName              String? // App-Name (z.B. "TTLock")
  ttlLockId                String? // TTLock Lock ID
  ttlLockPassword          String? // TTLock Passcode/Password
  onlineCheckInCompleted   Boolean                      @default(false)
  onlineCheckInCompletedAt DateTime?
  checkInDataUploaded      Boolean                      @default(false) // Gast hat Check-in-Link abgeschlossen (Dokumente hochgeladen)
  checkInDataUploadedAt    DateTime? // Wann wurden Dokumente hochgeladen
  invitationSentAt         DateTime? // Wann wurde die Check-in-Einladung versendet
  sentMessage              String? // Versendete WhatsApp-Nachricht (für Anzeige)
  sentMessageAt            DateTime? // Wann wurde die Nachricht versendet
  sireRegistered           Boolean                      @default(false)
  sireRegistrationId       String? // ID der SIRE-Registrierung
  sireRegisteredAt         DateTime?
  sireRegistrationError    String? // Fehlermeldung bei fehlgeschlagener Registrierung
  guestNationality         String? // Nationalität des Gastes (für SIRE)
  guestPassportNumber      String? // Passnummer (für SIRE)
  guestBirthDate           DateTime? // Geburtsdatum (für SIRE)
  // Gruppierung für zusammenhängende Reservationen (gleicher Gast, gleiche Daten, gleiche Kontaktdaten)
  reservationGroupId       String? // Hash aus checkIn+checkOut+contact+branch für Gruppierung
  isPrimaryInGroup         Boolean                      @default(true) // Primäre Reservation erhält die Mitteilung
  combinedPaymentLink      String? // Zahlungslink für Gesamtbetrag der Gruppe
  organizationId           Int
  organization             Organization                 @relation(fields: [organizationId], references: [id])
  branchId                 Int? // NEU: Optional für Branch-Zuordnung
  branch                   Branch?                      @relation(fields: [branchId], references: [id])
  taskId                   Int? // Verknüpfter Task
  task                     Task?                        @relation
  createdAt                DateTime                     @default(now())
  updatedAt                DateTime                     @updatedAt
  syncHistory              ReservationSyncHistory[]
  notificationLogs         ReservationNotificationLog[] @relation("NotificationLogs")
  whatsappMessages         WhatsAppMessage[]
  tourReservations         TourReservation[]

  @@index([organizationId])
  @@index([branchId]) // NEU: Index für Branch-Queries
  @@index([checkInDate])
  @@index([status])
  @@index([lobbyReservationId])
  @@index([paymentStatus])
  @@index([paymentDeadline]) // Für automatische Stornierung
  @@index([autoCancelEnabled]) // Für automatische Stornierung
  @@index([reservationGroupId]) // Für Gruppen-Abfragen
}

model ReservationSyncHistory {
  id            Int         @id @default(autoincrement())
  reservationId Int
  reservation   Reservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)
  syncType      String // 'created', 'updated', 'status_changed'
  syncData      Json? // Vollständige Daten zum Zeitpunkt der Synchronisation
  syncedAt      DateTime    @default(now())
  errorMessage  String?

  @@index([reservationId])
  @@index([syncedAt])
}

model ReservationNotificationLog {
  id               Int         @id @default(autoincrement())
  reservationId    Int
  reservation      Reservation @relation("NotificationLogs", fields: [reservationId], references: [id], onDelete: Cascade)
  notificationType String // 'invitation', 'pin', 'checkin_confirmation'
  channel          String // 'whatsapp', 'email', 'both'
  success          Boolean
  sentAt           DateTime    @default(now())
  sentTo           String? // Telefonnummer oder E-Mail-Adresse
  message          String? // Versendete Nachricht
  paymentLink      String? // Zahlungslink (falls relevant)
  checkInLink      String? // Check-in-Link (falls relevant)
  errorMessage     String? // Fehlermeldung (falls Fehler)
  createdAt        DateTime    @default(now())

  @@index([reservationId])
  @@index([sentAt])
  @@index([notificationType])
  @@index([success])
}

model WhatsAppPhoneNumberMapping {
  id            Int      @id @default(autoincrement())
  phoneNumberId String // WhatsApp Business API Phone Number ID
  branchId      Int // Branch, der diese Nummer verwendet
  isPrimary     Boolean  @default(false) // Primäre Nummer für diesen Branch
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  branch        Branch   @relation(fields: [branchId], references: [id])

  @@unique([phoneNumberId, branchId])
  @@index([phoneNumberId])
  @@index([branchId])
}

model WhatsAppConversation {
  id            Int               @id @default(autoincrement())
  phoneNumber   String // Telefonnummer des Users (mit Ländercode)
  userId        Int? // User-ID (falls identifiziert)
  branchId      Int // Branch, zu dem die Konversation gehört
  state         String // "idle", "request_creation", "task_creation", "waiting_for_responsible", etc.
  context       Json? // Kontext-Daten (z.B. teilweise erstellter Request)
  lastMessageAt DateTime          @default(now())
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  branch        Branch            @relation(fields: [branchId], references: [id])
  user          User?             @relation(fields: [userId], references: [id])
  messages      WhatsAppMessage[]

  @@unique([phoneNumber, branchId])
  @@index([phoneNumber])
  @@index([branchId])
  @@index([userId])
}

model WhatsAppMessage {
  id             Int                   @id @default(autoincrement())
  reservationId  Int? // Optional: Verknüpfung zu Reservation
  reservation    Reservation?          @relation(fields: [reservationId], references: [id], onDelete: SetNull)
  branchId       Int
  branch         Branch                @relation("WhatsAppMessages", fields: [branchId], references: [id], onDelete: Cascade)
  conversationId Int?
  conversation   WhatsAppConversation? @relation(fields: [conversationId], references: [id], onDelete: SetNull)

  // Nachrichtendetails
  direction   MessageDirection @default(outgoing) // 'outgoing' oder 'incoming'
  phoneNumber String // Telefonnummer (normalisiert)
  message     String // Nachrichtentext
  messageId   String? // WhatsApp Message ID (für Status-Updates)

  // Status (für ausgehende Nachrichten)
  status       MessageStatus? // 'sent', 'delivered', 'read', 'failed'
  errorMessage String? // Fehlermeldung bei Fehlern

  // Timestamps
  sentAt    DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reservationId])
  @@index([branchId])
  @@index([phoneNumber])
  @@index([sentAt])
  @@index([direction])
  @@index([status])
  @@index([conversationId])
}

// ============================================
// SHIFT PLANNING MODELS
// ============================================

enum AvailabilityType {
  available // Verfügbar
  preferred // Bevorzugt
  unavailable // Nicht verfügbar
}

enum ShiftStatus {
  scheduled // Geplant, aber noch nicht bestätigt
  confirmed // Bestätigt vom Mitarbeiter
  cancelled // Abgesagt
  swapped // Getauscht
}

enum SwapStatus {
  pending // Wartet auf Antwort
  approved // Genehmigt
  rejected // Abgelehnt
  cancelled // Abgebrochen
}

enum TourType {
  own
  external
}

enum TourBookingStatus {
  confirmed
  cancelled
  completed
  no_show
}

enum MessageDirection {
  outgoing
  incoming
}

enum MessageStatus {
  sent
  delivered
  read
  failed
}

// Schicht-Template: Definiert welche Schichten eine Rolle pro Tag haben kann
model ShiftTemplate {
  id        Int      @id @default(autoincrement())
  roleId    Int
  branchId  Int
  name      String // z.B. "Frühschicht", "Spätschicht", "Nachtschicht"
  startTime String // Format: "HH:mm" (z.B. "06:00")
  endTime   String // Format: "HH:mm" (z.B. "14:00")
  duration  Float? // Optional: Dauer in Stunden (z.B. 8.0) - nur für Anzeige/Statistiken
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      Role     @relation(fields: [roleId], references: [id])
  branch    Branch   @relation(fields: [branchId], references: [id])
  shifts    Shift[] // Tatsächliche Schichten basierend auf diesem Template

  @@unique([roleId, branchId, name]) // Pro Rolle/Branch darf ein Schichtname nur einmal vorkommen
  @@index([roleId, branchId])
}

// Verfügbarkeits-Regel für einen User
model UserAvailability {
  id       Int  @id @default(autoincrement())
  userId   Int
  branchId Int? // Optional: Branch-spezifische Verfügbarkeit
  roleId   Int? // Optional: Rolle-spezifische Verfügbarkeit

  // Verfügbarkeits-Pattern
  dayOfWeek Int? // 0=Sonntag, 1=Montag, ..., 6=Samstag (null = alle Tage)
  startTime String? // Format: "HH:mm" (null = ganzer Tag)
  endTime   String? // Format: "HH:mm" (null = ganzer Tag)

  // Oder: Spezifische Datumsbereiche
  startDate DateTime?
  endDate   DateTime?

  // Typ der Verfügbarkeit
  type AvailabilityType @default(available) // available, preferred, unavailable

  // Priorität (für automatische Planung)
  priority Int @default(5) // 1-10, höher = bevorzugt

  notes     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
  branch    Branch?  @relation(fields: [branchId], references: [id])
  role      Role?    @relation(fields: [roleId], references: [id])

  @@index([userId])
  @@index([branchId])
  @@index([roleId])
  @@index([dayOfWeek])
}

// Tatsächliche Schicht-Zuweisung
model Shift {
  id              Int      @id @default(autoincrement())
  shiftTemplateId Int
  branchId        Int
  roleId          Int
  userId          Int? // Zugewiesener User (null = noch nicht zugewiesen)
  date            DateTime // Datum der Schicht (nur Datum, Zeit wird ignoriert)
  startTime       DateTime // Vollständiges DateTime (Datum + Startzeit)
  endTime         DateTime // Vollständiges DateTime (Datum + Endzeit)

  // Status
  status ShiftStatus @default(scheduled) // scheduled, confirmed, cancelled, swapped

  // Metadaten
  notes       String?
  createdBy   Int // User-ID, der die Schicht erstellt hat
  confirmedAt DateTime?
  confirmedBy Int? // User-ID, der die Schicht bestätigt hat

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  shiftTemplate ShiftTemplate @relation(fields: [shiftTemplateId], references: [id])
  branch        Branch        @relation(fields: [branchId], references: [id])
  role          Role          @relation(fields: [roleId], references: [id])
  user          User?         @relation(fields: [userId], references: [id])
  creator       User          @relation("ShiftCreator", fields: [createdBy], references: [id])
  confirmer     User?         @relation("ShiftConfirmer", fields: [confirmedBy], references: [id])

  // Schichttausch
  swapRequests ShiftSwapRequest[] @relation("OriginalShift")
  swapTargets  ShiftSwapRequest[] @relation("TargetShift")

  @@index([branchId, date])
  @@index([roleId, date])
  @@index([userId, date])
  @@index([date])
  @@index([status])
}

// Schichttausch-Anfrage
model ShiftSwapRequest {
  id              Int        @id @default(autoincrement())
  originalShiftId Int // Schicht, die abgegeben werden soll
  targetShiftId   Int // Schicht, die übernommen werden soll
  requestedBy     Int // User, der den Tausch anfragt
  requestedFrom   Int // User, der die andere Schicht hat
  status          SwapStatus @default(pending)
  message         String?
  responseMessage String?
  respondedAt     DateTime?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  originalShift Shift @relation("OriginalShift", fields: [originalShiftId], references: [id])
  targetShift   Shift @relation("TargetShift", fields: [targetShiftId], references: [id])
  requester     User  @relation("SwapRequester", fields: [requestedBy], references: [id])
  requestee     User  @relation("SwapRequestee", fields: [requestedFrom], references: [id])

  @@index([requestedBy])
  @@index([requestedFrom])
  @@index([status])
}

model TourProvider {
  id            Int     @id @default(autoincrement())
  name          String
  phone         String?
  email         String?
  contactPerson String?
  notes         String?

  // Organisation & Branch
  organizationId Int
  organization   Organization @relation("TourProviders", fields: [organizationId], references: [id])
  branchId       Int?
  branch         Branch?      @relation("TourProviderBranches", fields: [branchId], references: [id])

  // Metadaten
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tours Tour[]

  @@index([organizationId])
  @@index([branchId])
  @@index([name])
}

model Tour {
  id          Int      @id @default(autoincrement())
  title       String
  description String?
  type        TourType @default(own)
  isActive    Boolean  @default(true)

  // Tour-Details
  duration        Int?
  maxParticipants Int?
  minParticipants Int?
  price           Decimal? @db.Decimal(10, 2)
  currency        String?  @default("COP")
  location        String?
  meetingPoint    String?
  includes        String?
  excludes        String?
  requirements    String?

  // Kommission (pro Tour)
  totalCommission         Decimal? @db.Decimal(10, 2)
  totalCommissionPercent  Decimal? @db.Decimal(5, 2)
  sellerCommissionPercent Decimal? @db.Decimal(5, 2)
  sellerCommissionFixed   Decimal? @db.Decimal(10, 2)

  // Externe Tour-Informationen
  externalProviderId Int?
  externalProvider   TourProvider? @relation(fields: [externalProviderId], references: [id])
  externalBookingUrl String?

  // Bilder/Medien
  imageUrl    String?
  galleryUrls Json?

  // Verfügbarkeit
  availableFrom     DateTime?
  availableTo       DateTime?
  recurringSchedule Json?

  // Organisation & Branch
  organizationId Int
  organization   Organization @relation("Tours", fields: [organizationId], references: [id])
  branchId       Int?
  branch         Branch?      @relation("TourBranches", fields: [branchId], references: [id])

  // Metadaten
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById Int?
  createdBy   User?    @relation("TourCreator", fields: [createdById], references: [id])

  // Relations
  bookings     TourBooking[]
  reservations TourReservation[]

  @@index([organizationId])
  @@index([branchId])
  @@index([isActive])
  @@index([title])
}

model TourBooking {
  id     Int  @id @default(autoincrement())
  tourId Int
  tour   Tour @relation(fields: [tourId], references: [id], onDelete: Restrict)

  // Buchungsdetails
  bookingDate          DateTime @default(now())
  tourDate             DateTime
  numberOfParticipants Int
  totalPrice           Decimal  @db.Decimal(10, 2)
  currency             String   @default("COP")

  // Kundeninformationen
  customerName  String
  customerEmail String?
  customerPhone String?
  customerNotes String?

  // Zahlungsstatus (analog zu Reservation)
  paymentStatus PaymentStatus @default(pending)
  amountPaid    Decimal?      @db.Decimal(10, 2)
  amountPending Decimal?      @db.Decimal(10, 2)
  paymentLink   String?

  // Automatische Stornierung
  paymentDeadline   DateTime? // Frist für Zahlung (z.B. jetzt + 1h)
  autoCancelEnabled Boolean   @default(false) // Automatische Stornierung aktiviert?
  reservedUntil     DateTime? // Bis wann ist die Reservation reserviert (für Anzeige)

  // Mitarbeiter-Kommission
  bookedById             Int?
  bookedBy               User?     @relation("TourBooker", fields: [bookedById], references: [id])
  commissionAmount       Decimal?  @db.Decimal(10, 2)
  commissionCalculatedAt DateTime?

  // Status
  status          TourBookingStatus @default(confirmed)
  cancelledBy     String?
  cancelledAt     DateTime?
  cancelledReason String?

  // Externe Tour-Buchung
  isExternal        Boolean @default(false)
  externalBookingId String?
  externalStatus    String?
  externalMessage   String?
  alternativeTours  Json?

  // Organisation & Branch
  organizationId Int
  organization   Organization @relation("TourBookings", fields: [organizationId], references: [id])
  branchId       Int?
  branch         Branch?      @relation("TourBookingBranches", fields: [branchId], references: [id])

  // Metadaten
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  reservations     TourReservation[]
  whatsappMessages TourWhatsAppMessage[]

  @@index([tourId])
  @@index([organizationId])
  @@index([branchId])
  @@index([bookedById])
  @@index([bookingDate])
  @@index([tourDate])
  @@index([paymentStatus])
  @@index([paymentDeadline]) // Index für effiziente Queries bei automatischer Stornierung
}

model TourReservation {
  id            Int         @id @default(autoincrement())
  tourId        Int
  tour          Tour        @relation(fields: [tourId], references: [id], onDelete: Restrict)
  bookingId     Int
  booking       TourBooking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  reservationId Int
  reservation   Reservation @relation(fields: [reservationId], references: [id], onDelete: Restrict)

  // Preisaufschlüsselung
  tourPrice          Decimal @db.Decimal(10, 2)
  accommodationPrice Decimal @db.Decimal(10, 2)
  currency           String  @default("COP")

  // Zahlungsstatus
  tourPricePaid        Decimal? @db.Decimal(10, 2)
  tourPricePending     Decimal? @db.Decimal(10, 2)
  accommodationPaid    Decimal? @db.Decimal(10, 2)
  accommodationPending Decimal? @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([reservationId, bookingId])
  @@index([tourId])
  @@index([bookingId])
  @@index([reservationId])
}

model TourWhatsAppMessage {
  id        Int         @id @default(autoincrement())
  bookingId Int
  booking   TourBooking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  // Nachrichtendetails
  direction   MessageDirection @default(outgoing)
  message     String
  phoneNumber String
  sentAt      DateTime         @default(now())

  // Status
  status       MessageStatus @default(sent)
  errorMessage String?

  // Verarbeitung
  processed     Boolean   @default(false)
  processedAt   DateTime?
  action        String?
  extractedData Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([bookingId])
  @@index([phoneNumber])
  @@index([sentAt])
  @@index([processed])
}

// ============================================
// PASSWORD MANAGER MODELS
// ============================================

model PasswordEntry {
  id              Int                           @id @default(autoincrement())
  title           String
  url             String?
  username        String?
  password        String // Verschlüsselt (AES-256-GCM)
  notes           String?                       @db.Text
  organizationId  Int?
  createdById     Int
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt
  organization    Organization?                 @relation(fields: [organizationId], references: [id])
  createdBy       User                          @relation("PasswordEntryCreator", fields: [createdById], references: [id])
  rolePermissions PasswordEntryRolePermission[]
  userPermissions PasswordEntryUserPermission[]
  auditLogs       PasswordEntryAuditLog[]

  @@index([organizationId])
  @@index([createdById])
  @@index([createdAt])
}

model PasswordEntryRolePermission {
  id        Int           @id @default(autoincrement())
  entryId   Int
  roleId    Int
  canView   Boolean       @default(false)
  canEdit   Boolean       @default(false)
  canDelete Boolean       @default(false)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  entry     PasswordEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  role      Role          @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([entryId, roleId])
  @@index([entryId])
  @@index([roleId])
}

model PasswordEntryUserPermission {
  id        Int           @id @default(autoincrement())
  entryId   Int
  userId    Int
  canView   Boolean       @default(false)
  canEdit   Boolean       @default(false)
  canDelete Boolean       @default(false)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  entry     PasswordEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([entryId, userId])
  @@index([entryId])
  @@index([userId])
}

model PasswordEntryAuditLog {
  id        Int           @id @default(autoincrement())
  entryId   Int
  userId    Int
  action    String // 'view', 'view_password', 'copy_password', 'create', 'update', 'delete'
  details   Json? // Zusätzliche Details (z.B. geänderte Felder)
  ipAddress String?
  userAgent String?
  createdAt DateTime      @default(now())
  entry     PasswordEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  user      User          @relation("PasswordEntryAuditLogUser", fields: [userId], references: [id])

  @@index([entryId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
}

// ============================================
// PRICE ANALYSIS MODELS
// ============================================

model OTAListing {
  id Int @id @default(autoincrement())

  // Konkurrenz-Informationen
  platform   String // 'booking.com', 'hostelworld.com', etc.
  listingId  String // Eindeutige ID des Inserats auf der OTA-Plattform
  listingUrl String? // URL zum Inserat

  // Ort und Zimmertyp (für Discovery und Vergleich)
  city     String // Stadt (z.B. "Medellín") - Hauptfilter für Discovery
  country  String? // Land (z.B. "Kolumbien") - Optional für genauere Filterung
  roomType String // 'private' | 'dorm' (entspricht 'privada' | 'compartida' aus LobbyPMS)
  roomName String? // Name des Zimmers auf OTA (z.B. "Private Room", "Dorm Bed")

  // Optional: Branch-Zuordnung (für Filterung, nicht für Verknüpfung)
  branchId Int? // Optional: Welcher Branch soll diese Konkurrenz sehen?
  branch   Branch? @relation(fields: [branchId], references: [id])

  // Status
  isActive      Boolean   @default(true)
  discoveredAt  DateTime  @default(now()) // Wann wurde das Listing gefunden?
  lastScrapedAt DateTime? // Letztes Scraping-Datum

  // Metadaten
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  priceData   OTAPriceData[]
  competitors Competitor[]

  @@unique([platform, listingId, city]) // Eindeutig pro Plattform, Listing und Stadt
  @@index([city])
  @@index([country])
  @@index([roomType])
  @@index([branchId])
  @@index([platform])
}

model OTAPriceData {
  id        Int        @id @default(autoincrement())
  listingId Int
  listing   OTAListing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // Datum und Preis
  date     DateTime @db.Date
  price    Decimal  @db.Decimal(10, 2)
  currency String   @default("COP")

  // Verfügbarkeit
  available      Boolean @default(true)
  availableRooms Int? // Anzahl verfügbarer Zimmer

  // Metadaten
  scrapedAt DateTime @default(now()) // Wann wurden die Daten gesammelt
  source    String? // 'rate_shopper' | 'api' | 'manual'

  @@unique([listingId, date])
  @@index([listingId])
  @@index([date])
  @@index([scrapedAt])
  @@index([listingId, date])
}

model PriceAnalysis {
  id       Int    @id @default(autoincrement())
  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  // Zeitraum
  analysisDate DateTime @db.Date // Datum der Analyse
  startDate    DateTime @db.Date // Startdatum des analysierten Zeitraums
  endDate      DateTime @db.Date // Enddatum (normalerweise +3 Monate)

  // Zimmerkategorie
  categoryId Int? // LobbyPMS category_id
  roomType   String // 'private' | 'dorm'

  // Analyse-Daten
  currentPrice Decimal? @db.Decimal(10, 2) // Aktueller Preis
  averagePrice Decimal? @db.Decimal(10, 2) // Durchschnittspreis im Zeitraum
  minPrice     Decimal? @db.Decimal(10, 2) // Minimalpreis
  maxPrice     Decimal? @db.Decimal(10, 2) // Maximalpreis

  // Belegung
  occupancyRate  Decimal? @db.Decimal(5, 2) // Belegungsrate (0-100)
  availableRooms Int? // Verfügbare Zimmer

  // Wettbewerb
  competitorAvgPrice Decimal? @db.Decimal(10, 2) // Durchschnittspreis der Konkurrenz
  pricePosition      String? // 'above' | 'below' | 'equal' // Position im Markt

  // Metadaten
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  recommendations PriceRecommendation[]

  @@unique([branchId, analysisDate, categoryId, roomType])
  @@index([branchId])
  @@index([analysisDate])
  @@index([categoryId])
  @@index([roomType])
  @@index([branchId, analysisDate])
  @@index([categoryId, analysisDate])
  @@index([roomType, analysisDate])
}

model PriceRecommendation {
  id         Int            @id @default(autoincrement())
  analysisId Int?
  analysis   PriceAnalysis? @relation(fields: [analysisId], references: [id])

  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  // Datum und Zimmer
  date       DateTime @db.Date
  categoryId Int? // LobbyPMS category_id
  roomType   String // 'private' | 'dorm'

  // Empfehlung
  recommendedPrice   Decimal  @db.Decimal(10, 2)
  currentPrice       Decimal? @db.Decimal(10, 2)
  priceChange        Decimal? @db.Decimal(10, 2) // Differenz zum aktuellen Preis
  priceChangePercent Decimal? @db.Decimal(5, 2) // Prozentuale Änderung

  // Begründung
  appliedRules Json? // Array der angewendeten Regeln
  reasoning    String? // Textuelle Begründung

  // Status
  status     String    @default("pending") // 'pending' | 'approved' | 'applied' | 'rejected'
  appliedAt  DateTime? // Wann wurde die Empfehlung ins LobbyPMS eingespielt
  appliedBy  Int? // User-ID, der die Empfehlung angewendet hat
  approvedAt DateTime?
  approvedBy Int? // User-ID, der die Empfehlung genehmigt hat

  // Metadaten
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, date, categoryId, roomType])
  @@index([branchId])
  @@index([date])
  @@index([categoryId])
  @@index([roomType])
  @@index([status])
  @@index([branchId, date, status])
  @@index([categoryId, date])
  @@index([status, date])
}

model PricingRule {
  id       Int    @id @default(autoincrement())
  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  // Regel-Definition
  name        String // Name der Regel (z.B. "Hohe Belegung - Preise erhöhen")
  description String? // Beschreibung

  // Bedingungen
  conditions Json // JSON mit Bedingungen:
  // {
  //   "occupancyRate": { "operator": ">", "value": 80 },
  //   "competitorPriceDiff": { "operator": "<", "value": -10 },
  //   "dayOfWeek": [5, 6] // Wochenende
  // }

  // Aktion
  action Json // JSON mit Aktion:
  // {
  //   "type": "increase" | "decrease" | "set",
  //   "value": 10, // Prozent oder absoluter Wert
  //   "maxChange": 20, // Maximale Änderung in Prozent
  //   "minPrice": 50000, // Minimalpreis
  //   "maxPrice": 200000, // Maximalpreis
  //   "cumulative": true // Kumulativ oder nicht
  // }

  // Anwendungsbereich
  roomTypes   Json? // ['private', 'dorm'] oder null für alle
  categoryIds Json? // [34280, 34281] oder null für alle

  // Priorität
  priority Int @default(0) // Höhere Zahl = höhere Priorität

  // Status
  isActive Boolean @default(true)

  // Metadaten
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdBy     Int? // User-ID
  createdByUser User?    @relation(fields: [createdBy], references: [id])

  @@index([branchId])
  @@index([isActive])
  @@index([priority])
}

model CompetitorGroup {
  id       Int    @id @default(autoincrement())
  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  // Gruppen-Informationen
  name        String // Name der Konkurrenzgruppe (z.B. "Medellín Hostels")
  description String? // Beschreibung

  // Ort
  city    String // Stadt (z.B. "Medellín")
  country String? // Land (z.B. "Kolumbien")

  // Status
  isActive Boolean @default(true)

  // Metadaten
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  competitors Competitor[]

  @@index([branchId])
  @@index([city])
  @@index([isActive])
}

model Competitor {
  id                Int             @id @default(autoincrement())
  competitorGroupId Int
  competitorGroup   CompetitorGroup @relation(fields: [competitorGroupId], references: [id], onDelete: Cascade)

  // Hostel-Informationen
  name       String // Hostel-Name (z.B. "Los Patios Hostel")
  searchName String? // Alternative Suchbegriffe (z.B. "Los Patios Medellín")

  // OTA-Informationen (optional, falls bereits bekannt)
  bookingComUrl  String? // Booking.com URL
  hostelworldUrl String? // Hostelworld URL
  otherUrls      Json? // Weitere URLs (Array)

  // Zuordnung zu OTAListing (falls bereits vorhanden)
  otaListingId Int?
  otaListing   OTAListing? @relation(fields: [otaListingId], references: [id])

  // Status
  isActive         Boolean   @default(true)
  lastSearchedAt   DateTime? // Wann wurde zuletzt gesucht?
  lastPriceFoundAt DateTime? // Wann wurde zuletzt ein Preis gefunden?

  // Metadaten
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([competitorGroupId])
  @@index([isActive])
  @@index([otaListingId])
}

model RateShoppingJob {
  id       Int    @id @default(autoincrement())
  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  // Job-Informationen
  platform String // 'booking.com', 'hostelworld.com', etc.
  status   String @default("pending") // 'pending' | 'running' | 'completed' | 'failed'

  // Zeitraum
  startDate DateTime @db.Date
  endDate   DateTime @db.Date

  // Ergebnisse
  listingsFound   Int   @default(0)
  pricesCollected Int   @default(0)
  errors          Json? // Array von Fehlern

  // Metadaten
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([branchId])
  @@index([status])
  @@index([platform])
}
